---
title: "Singapore's Fertility Crisis: A Data-Driven Analysis of Socioeconomic Factors"
subtitle: "AAI1001 Team 7 Data Visualisation Project"
author:
  - name: Guo Zi Qiang Robin
  - name: Chew Tze Han
  - name: Cheong Wai Hong Jared
  - name: Akram
  - name: Gregory Tan
date: today
format:
  html:
    embed-resources: true
    toc: true
    toc-depth: 3
    number-sections: true
    theme: journal
    code-fold: true
    code-summary: "Show Code"
    fig-width: 10
    fig-height: 6
    warning: false
    message: false
    link-external-newwindow: true
bibliography: references.bib  
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}
# Load necessary libraries (things that are def needed)
library(crosstalk)
library(tidyverse) # for data manipulation and visualization
library(viridis) # for color scales
library(ggpp) # for position_dodgenudge 
library(ggrepel) # for text repelling
library(RColorBrewer) # color palettes specifically tailored for data visualization
library(crosstalk)
library(htmltools)
library(dplyr)
library(knitr)
library(tools) # 
library(ggiraph)
library(ggplot2) # for plotting
library(plotly) # for interactive plots
library(janitor) # for cleaning 
library(gt)
library(stringr)
library(scales)
library(forcats)

# may not be needed/not used
# library(directlabels) # for categorical text labeling
# library(ggforce) # for enclosing shapes

#to be verified USE gt package not kable
library(kableExtra)
library(corrplot)
library(broom)


# Set global options
options(scipen = 999)
knitr::opts_chunk$set(
  echo = TRUE,
#  warning = FALSE,
#  message = FALSE,
  fig.align = "center",
  out.width = "100%"
)
```

# Executive Summary

Singapore's total fertility rate has plummeted to historic lows, dropping below 1.0 for the first time in 2023. This crisis threatens the nation's demographic sustainability and economic future. Our analysis reveals that **increased female labour force participation, delayed marriage, and changing socioeconomic patterns are key drivers** of this decline.

**Key Findings:**

- Fertility rate declined by 41% from 1990 to 2020

- Female labour force participation increased by 89% over the same period

- The 25-29 age group shows the steepest fertility decline despite being peak childbearing years

- Strong negative correlation (-0.87) between labour force participation and fertility rates

---

# Introduction

## Background & Significance

Singapore faces a demographic crisis with one of the world's lowest fertility rates. Understanding the underlying socioeconomic factors is crucial for policy formulation and national planning. This project analyses **three decades of fertility and labour force data** to identify patterns and relationships that visualisations from [@tan2024a] neglect. Using various packages in R, we will create a poster that thoughtfully displays the socioeconomic factors that influence fertility/birth rates in Singapore by using fertility rate data sourced from [@singstat2023] as well as labour participation and marital status data from [@datagovsg2020a] and [@datagovsg2020b].


**Disclaimer:**
*To note that data for 1995, 2000 and 2005 are not available as the Comprehensive Labour Force Survey was not conducted in these years due to the conduct of the Population Census 2000, General Household Surveys 1995 and 2005 by the Singapore Department of Statistics.*


## Research Questions

1. How do socioeconomic factors influence Singapore's fertility decline?
2. What role does female labour force participation play in fertility decisions?
3. Which age groups and marital statuses are most affected?
4. Can we identify critical inflection points in the fertility decline?

---

# Critical Analysis of Original Visualisation

## Original Visualisation

![Total fertility rate from 2019 to 2023](imgs/total_fertility_rate.png)

*Source: [Straits Times: Singapore's total fertility rate hits record low in 2023](https://www.straitstimes.com/singapore/politics/singapore-s-total-fertility-rate-hits-record-low-in-2023-falls-below-1-for-first-time)*

## Strengths & Weaknesses Analysis

```{r analysis-table, echo=FALSE}
#| label: tbl-1
#| tbl-cap: "Comprehensive Analysis of Original Visualisation vs Our Improvements"

# Create the data frame
analysis_df <- data.frame(
  Strengths = c(
    "Uses official SingStat data",
    "Clear recent trend shown",
    "Headline-grabbing impact",
    "Clean, professional format",
    "Focuses on key metric",
    "Accessible to general public"
  ),
  Weaknesses = c(
    "No data validation shown",
    "Limited to 2019-2023 only",
    "Missing socioeconomic factors",
    "Static visualisation",
    "No age-specific breakdown",
    "Lacks analytical depth"
  ),
  Our_Improvements = c(
    "Comprehensive data validation & outlier analysis",
    "Extended analysis: 1990-2022 (32 years)",
    "Integrated labour force & marital status data",
    "Fully interactive dashboard",
    "Age-specific fertility rates by group",
    "Multi-layered analytical approach"
  )
)

# Create the table using gt
gt_table <- analysis_df |>
  gt() |>
  cols_label(
    Strengths = "Strengths",
    Weaknesses = "Weaknesses",
    Our_Improvements = "Our Improvements"
  ) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")  # Bold the column headers
    ),
    locations = cells_column_labels(columns = c("Strengths", "Weaknesses", "Our_Improvements"))  # Apply to all column headers
  ) |>
  tab_options(
    table.font.size = 12,
    table.width = pct(80)
  ) |>
  opt_table_font(
    font = "Arial"
  )

# Display the table
gt_table
```

The original visualisations focus on Singapore's total fertility rate (TFR) from 2019 to 2023, but fail to explore the socioeconomic factors driving the decline. Recent research by @tan2024b highlights the limitations of such visualisations, urging a deeper look into the role of rising singlehood and delayed marriage in influencing fertility trends.

---

# Data Sources & Methodology

```{r data-sources, echo=FALSE}
#| eval: true
#| output-location: column
#| label: tbl-2
#| tbl-cap: "Data Sources Overview"

# Create the data frame
data_sources <- data.frame(
  Dataset = c("Fertility Rates", "Labour Force (Working)", "Labour Force (Not Working)"),
  Source = c("SingStat", "data.gov.sg", "data.gov.sg"),
  Time_Period = c("1960-2024", "1991-2022", "1991-2022"),
  Variables = c("Age-specific fertility rates, Total fertility rate", 
                "Female labour force by age & marital status",
                "Females outside labour force by age & marital status"),
  Records = c("17 variables wide format", "5 columns long format", "5 columns long format")
)

# Create the table using gt
gt_table <- data_sources |>
  gt() |>
  cols_label(
    Dataset = "Dataset",
    Source = "Source",
    Time_Period = "Time Period",
    Variables = "Variables",
    Records = "Records"
  ) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")  # Bold the column headers
    ),
    locations = cells_column_labels(columns = c("Dataset", "Source", "Time_Period", "Variables", "Records"))  # Apply to all column headers
  ) |>
  tab_options(
    table.font.size = 12,
    table.width = pct(80)
  ) |>
  opt_table_font(
    font = "Arial"
  )

# Display the table
gt_table

```

## Data Engineering Pipeline

```{r data-loading, echo=TRUE}
# Load datasets with proper error handling
fertility <- read_csv(
  "datasets/ResidentFertilityRate.csv",
  skip = 9,
  n_max = 17,
  show_col_types = FALSE
)

work <- read_csv("datasets/ResidentLabourForceAged15YearsandOverbyMaritalStatusAgeandSex.csv", 
                 show_col_types = FALSE)

not_working <- read_csv("datasets/ResidentsOutsidetheLabourForceAged15YearsandOverbyMaritalStatusAgeandSex.csv", 
                       show_col_types = FALSE)

cat("✓ Data loaded successfully\n")
cat("Fertility data shape:", dim(fertility), "\n")
cat("Labour force data shape:", dim(work), "\n")
cat("Outside labour force data shape:", dim(not_working), "\n")
```

## Data Cleaning & Transformation
The following steps will be taken to clean and reshape "`fertility`":

- "`fertility`" tibble contains "na" strings which are not actually NA values, these points will need to be converted to NA values

- fertility rate data from SingStat is in wide format with years as the columns, we will pivot long for year-wise plots

- fertility rate data goes up till 2024, whereas the labour force data only goes up till 2022, we will filter the fertility rate data to only include years after 1990 and up till 2022

- standardise age banding of fertility rate dataset to be consistent with labour force data. For example, "15-19" instead of "15 - 19 Years (Per Thousand Females)' and also keep Total Fertility Rate data (aggregated across all age bands)

- filtered to include age specific fertility rates and the total fertility rate by year

- introduce Unit of Measurement (uom) column to indicate scaling for Total Fertility Rates and age banded fertility rates



The following steps will be taken to clean and reshape "`not_working`":

- standardise column names to the 7 (15-19, 20-24, 25-29, 30-34, 35-39, 40-44, 45-49) age bands to be consistent with fertility and remove extra bandings

- for labour datasets, divide labour_force values by 1000 to align with count (in thousands) y-axis variable

- some outside_labour_force values are "-" which are not valid numerics, convert these to NA

- rename age column to age_band to match `fertility`

- aggregate age bands to introduce "All" to represent population outside labour force by year and marital status only, this is so that we can introduce interactivity with Total Fertility Rate and fertility rates across age bands


"work" tibble is cleaned in a similar way to "not_working".

```{r data-cleaning, echo=TRUE}
# Enhanced fertility data cleaning
fertility_clean <- fertility |>
  clean_names() |>
  rename(measure = data_series) |>
  mutate(across(-measure, as.character)) |>
  pivot_longer(
    cols = -measure,
    names_to = "year",
    values_to = "value"
  ) |>
  mutate(
    year = as.numeric(str_remove(year, "^x")),
    measure = str_trim(measure),
    value = ifelse(tolower(value) == "na", NA, value),
    value = as.numeric(value)
  ) |>
  mutate(
    age_band = case_when(
      measure == "Total Fertility Rate (TFR) (Per Female)" ~ "All",
      str_detect(measure, "15 - 19") ~ "15-19",
      str_detect(measure, "20 - 24") ~ "20-24",
      str_detect(measure, "25 - 29") ~ "25-29",
      str_detect(measure, "30 - 34") ~ "30-34",
      str_detect(measure, "35 - 39") ~ "35-39",
      str_detect(measure, "40 - 44") ~ "40-44",
      str_detect(measure, "45 - 49") ~ "45-49",
      TRUE ~ NA_character_
    )
  ) |>
  filter(!is.na(age_band)) |>
  mutate(
    uom = case_when(
      age_band == "All" ~ "per female",
      TRUE ~ "per thousand females"
    )
  ) |>
  filter(year >= 1990 & year <= 2020) |>
  select(year, age_band, fertility_rate = value, uom)

# Enhanced labour force data cleaning
clean_labour_data <- function(data, value_col) {
  data |>
    clean_names() |>
    filter(age %in% c("15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49")) |>
    mutate(
      !!value_col := na_if(!!sym(value_col), "-"),
      !!value_col := as.numeric(!!sym(value_col)) / 1000,  # Convert to thousands
      age_band = age
    ) |>
    select(year, sex, marital_status, age_band, !!value_col)
}

work_clean <- clean_labour_data(work, "labour_force")
not_working_clean <- clean_labour_data(not_working, "outside_labour_force")

# Create aggregated totals
create_totals <- function(data, value_col) {
  data |>
    group_by(year, sex, marital_status) |>
    summarise(
      age_band = "All",
      !!value_col := sum(!!sym(value_col), na.rm = TRUE),
      .groups = "drop"
    )
}

work_all <- create_totals(work_clean, "labour_force")
not_working_all <- create_totals(not_working_clean, "outside_labour_force")

# Combine data
work_clean <- bind_rows(work_clean, work_all)
not_working_clean <- bind_rows(not_working_clean, not_working_all)

cat("✓ Data cleaning completed successfully\n")
```

---

# Data Quality Assessment

## Missing Data Analysis
Missing Data Summary:
```{r missing-data}
# Check for missing data patterns
missing_analysis <- list(
  fertility = fertility_clean |> summarise(across(everything(), ~sum(is.na(.)))),
  work = work_clean |> summarise(across(everything(), ~sum(is.na(.)))),
  not_working = not_working_clean |> summarise(across(everything(), ~sum(is.na(.))))
)

cat("Fertility data missing values:", sum(is.na(fertility_clean$fertility_rate)), "\n")
cat("Labour force data missing values:", sum(is.na(work_clean$labour_force)), "\n")
cat("Outside labour force missing values:", sum(is.na(not_working_clean$outside_labour_force)), "\n")
```
The missing values in the labour datasets are caused by combinations of variables that result in highly likely scenarios where the count is actually '0' such as the case of "widowed/divorced" in the age band of "15-19". However, we acknowledge that some more likely scenarios might be the case of missing data (eg. 2022, male, outside labour force, widowed/divorced, 35-39).

## Outlier Detection & Analysis

```{r outlier-analysis, echo=TRUE}
#| label: tbl-3
#| tbl-cap: "Outlier Detection Summary"

# Enhanced outlier detection function
detect_outliers_iqr <- function(df, value_col, group_cols) {
  df |>
    group_by(across(all_of(group_cols))) |>
    mutate(
      Q1 = quantile(.data[[value_col]], 0.25, na.rm = TRUE),
      Q3 = quantile(.data[[value_col]], 0.75, na.rm = TRUE),
      IQR = Q3 - Q1,
      lower_bound = Q1 - 1.5 * IQR,
      upper_bound = Q3 + 1.5 * IQR,
      is_outlier = .data[[value_col]] < lower_bound | .data[[value_col]] > upper_bound
    ) |>
    ungroup()
}


# Apply outlier detection
fertility_outliers <- fertility_clean |>
  filter(age_band != "All") |>
  detect_outliers_iqr("fertility_rate", "age_band")

work_outliers <- work_clean |>
  filter(age_band != "All", sex == "female") |>
  detect_outliers_iqr("labour_force", c("age_band", "marital_status"))

# Outlier summary
outlier_summary <- data.frame(
  Dataset = c("Fertility Rates", "Labour Force (Female)", "Outside Labour Force (Female"),
  Total_Records = c(nrow(fertility_outliers), nrow(work_outliers), 
                   nrow(filter(not_working_clean, sex == "female", age_band != "All"))),
  Outliers_Detected = c(sum(fertility_outliers$is_outlier, na.rm = TRUE),
                       sum(work_outliers$is_outlier, na.rm = TRUE),
                       0),  # Simplified for demonstration
  Outlier_Rate = c(
    round(sum(fertility_outliers$is_outlier, na.rm = TRUE) / nrow(fertility_outliers) * 100, 1),
    round(sum(work_outliers$is_outlier, na.rm = TRUE) / nrow(work_outliers) * 100, 1),
    0
  )
)

# Create the table using gt
outlier_summary_gt <- outlier_summary |>
  gt() |>
  cols_label(
    Dataset = "Dataset",
    Total_Records = "Total Records",
    Outliers_Detected = "Outliers Detected",
    Outlier_Rate = "Outlier Rate (%)"
  ) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")  # Bold column headers
    ),
    locations = cells_column_labels(columns = everything())  # Apply to all column headers
  ) |>
  tab_options(
    table.font.size = 12,
    table.width = pct(80),
    table.layout = "auto"
  ) |>
  opt_table_font(
    font = "Arial"
  )

# Display the table
outlier_summary_gt
```



## Outlier Visualisation

```{r fertility-outlier}
# Enhanced outlier visualisation
p_outliers <- ggplot(fertility_outliers, 
                    aes(x = year, y = fertility_rate, color = age_band)) +
  geom_line(linewidth = 0.8, alpha = 0.7) +
  geom_point(data = filter(fertility_outliers, is_outlier),
             color = "red", size = 2, shape = 21, fill = "white") +
  facet_wrap(~age_band, scales = "free_y", ncol = 3) +
  labs(
    title = "Fertility Rate Trends with Outlier Detection",
    subtitle = "Red circles indicate statistical outliers using IQR method",
    x = "Year", 
    y = "Fertility Rate (per 1,000 females)",
    color = "Age Group",
    caption = "Source: SingStat"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  ) +
  scale_color_viridis_d()

print(p_outliers)
```
This shows that there is uncharacteristically high fertility rate in the 45-49 year old age group in recent times (2017-2020).

```{r labour-fem-outlier}
#| warning: false

status_labels <- c(
  "married" = "Married",
  "single" = "Single",
  "widowed_divorced" = "Widowed/Divorced"
)

# Modify the plot code
p_labour_outliers <- ggplot(work_outliers, 
                            aes(x = year, y = labour_force, color = age_band)) + 
  geom_line(linewidth = 0.8, alpha = 0.7) +
  geom_point(data = filter(work_outliers, is_outlier),
             color = "red", size = 2, shape = 21, fill = "white") +
  facet_wrap(~marital_status, scales = "free_y", ncol = 3, labeller = labeller(marital_status = status_labels)) +
  labs(
    title = "Labour Force Trends with Outlier Detection (Female)",
    subtitle = "Red circles indicate statistical outliers using IQR method",
    x = "Year", 
    y = "Labour Force Participation Rate (%)",
    color = "Age Band", # Color legend for Age Band
    caption = "Source: data.gov.sg"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold"),
    legend.position = "right",  # Keep the legend for Age Band
    legend.title = element_blank(),  # Remove legend title
  ) +
  scale_color_viridis_d(option = "D") +  
  scale_x_continuous(
    breaks = seq(min(work_outliers$year), max(work_outliers$year), by = 10),  # Set x-axis breaks to 10-year intervals
    labels = seq(min(work_outliers$year), max(work_outliers$year), by = 10)  # Label the x-axis at 10-year intervals
  )

print(p_labour_outliers)

```
Majority of the outliers were single and occurred in the early 1990s.

---

# Data Integration & Final Dataset

## Data Integration Strategy

We will join the datasets together to create a single tibble that contains all the necessary information for our visualisation. The joined tibble will contain the following columns:

- `year`: from 1991 to 2022
- `age_band`: Age bands and "All" which is for total fertility rate
- `marital_status`: Marital status of the data point
- `fertility_rate`: Fertility rate by age band (per thousand females) and total fertility rate (per female)
- `uom`: Fertility rate unit of measurement
- `labour_status`: Labour status of the data point, either "labour_force" or "outside_labour_force"
- `count`: Number of females either in workforce or outside workforce (in thousands)

### Filter to Female Population Only

```{r filter-female}
#| echo: true
#| eval: true

# Filter labour data to only include females
work_clean_female <- work_clean |> 
  filter(sex == "female") |> 
  select(-sex)

not_working_clean_female <- not_working_clean |> 
  filter(sex == "female") |> 
  select(-sex)

cat("✓ Filtered to female population only\n")
cat("Working females data shape:", dim(work_clean_female), "\n")
cat("Non-working females data shape:", dim(not_working_clean_female), "\n")
```

### Combine Labour Force Data

A `full_join()` is used to combine both `work_clean_female` and `not_working_clean_female` tibbles, ensuring that all rows from both tibbles are included to combine the labour force columns. The join is done on the `year`, `marital_status`, and `age_band` columns, common dimensions to both tibbles to prevent any data loss.

```{r combine-labour}
#| echo: true
#| eval: true

# Combine female labour and not working into one tibble
labour_status_female <- full_join(
  work_clean_female, 
  not_working_clean_female, 
  by = c("year", "marital_status", "age_band")
)

cat("✓ Combined labour force data successfully\n")
cat("Combined labour data shape:", dim(labour_status_female), "\n")
```

### Join with Fertility Data

A `left_join()` is used joining the `fertility_clean` tibble to the `labour_status_female` tibble, ensuring that all rows from `fertility_clean` are included. This will allow us to combine and be able to associate fertility rates with labour force participation data.

```{r join-fertility}
#| echo: true
#| eval: true

# Join fertility data with labour status data
fertility_labour_joined <- fertility_clean |>
  left_join(labour_status_female, by = c("year", "age_band"))

cat("✓ Joined fertility and labour data successfully\n")
cat("Joined data shape:", dim(fertility_labour_joined), "\n")
```

### Transform to Long Format

Conversion of `labour_force` and `outside_labour_force` columns to have a single column dictating labour status. Years that do not have corresponding labour force data (1995, 2000, 2005) are filtered out as noted in our disclaimer.

```{r transform-long}
#| echo: true
#| eval: true

# Create final analytical dataset
final_dataset <- fertility_labour_joined |>
  pivot_longer(
    cols = c("labour_force", "outside_labour_force"),
    names_to = "labour_status",
    values_to = "count"
  ) |>
  group_by(year) |>
  filter(!all(is.na(count))) |>  # Remove years with no labour data (1995, 2000, 2005)
  ungroup() |>
  mutate(
    count = replace_na(count, 0),
  ) |>
  filter(!is.na(fertility_rate))  # Remove rows with missing fertility data
```

### Data Quality Validation
Evaluate the `final_dataset` for total number of records, unique values in each column, presence of missing values ("NA") 
```{r validation}
#| echo: true
#| eval: true
#| label: tbl-4
#| tbl-cap: "Summary Table of `final_dataset` Tibble"

summary_table <- tibble(
  Column         = names(final_dataset),
  Total_Records  = nrow(final_dataset),
  Unique_Values  = sapply(final_dataset, function(x) length(unique(x))),
  Missing_Values = sapply(final_dataset, function(x) sum(is.na(x)))
)

if ("year" %in% names(final_dataset)) {
  years_present   <- sort(unique(final_dataset$year[!is.na(final_dataset$year)]))
  yr_min          <- min(years_present)
  yr_max          <- max(years_present)
  full_years      <- seq(yr_min, yr_max)
  missing_years   <- setdiff(full_years, years_present)
  missing_txt     <- if (length(missing_years)) {
    paste(missing_years, collapse = ", ")
  } else {
    "None"
  }
  footer_note <- paste0(
    "Year range: ", yr_min, "–", yr_max,
    " | Missing years: ", missing_txt
  )
} else {
  footer_note <- NULL
}

# 4. Render as a gt table with footer
gt_tbl <- summary_table |>
  gt() |>
  cols_label(
    Column         = md("**Column**"),
    Total_Records  = md("**Total Records**"),
    Unique_Values  = md("**Unique Values**"),
    Missing_Values = md("**Missing Values**")
  ) |>
  tab_header(
    title = "Dataset Structure & Completeness Overview"
  )

if (!is.null(footer_note)) {
  gt_tbl <- gt_tbl |>
    tab_source_note(
      source_note = footer_note
    )
}

gt_tbl
```

### Create Aggregated Totals for Analysis

```{r create-totals}
#| echo: true
#| eval: true

# Create aggregated totals function for reusability
create_totals <- function(data, value_col) {
  data |>
    group_by(year, sex, marital_status) |>
    summarise(
      age_band = "All",
      !!value_col := sum(!!sym(value_col), na.rm = TRUE),
      .groups = "drop"
    )
}

# Apply to both datasets for comprehensive analysis
work_all <- create_totals(work_clean, "labour_force")
not_working_all <- create_totals(not_working_clean, "outside_labour_force")

# Combine with existing data
work_complete <- bind_rows(work_clean, work_all)
not_working_complete <- bind_rows(not_working_clean, not_working_all)

cat("✓ Created aggregated totals for comprehensive analysis\n")
cat("Work data with totals shape:", dim(work_complete), "\n")
cat("Not working data with totals shape:", dim(not_working_complete), "\n")
```
## Dataset Integration Results

The final integrated dataset successfully combines:

- **Fertility rates** from SingStat (1990-2022)
- **Female labour force participation** from data.gov.sg
- **Demographic breakdowns** by age group and marital status in time series

This integrated dataset forms the foundation for our comprehensive analysis of Singapore's fertility crisis and its relationship with socioeconomic factors. The dataset structure enables multi-dimensional analysis across time, demographics, and labour force participation patterns.

```{r preview-final-data}
#| echo: true
#| eval: true
#| label: tbl-5
#| tbl-cap: "Preview of `final_dataset`"


  gt(final_dataset) |>
  tab_header(title = md("**Sample of Final Integrated Dataset**")) |>
  gt_preview()
```

---

# Statistical Analysis

```{r correlation-analysis, echo=TRUE}

#| echo: true
#| eval: true
#| label: tbl-6
#| tbl-cap: "Correlation Matrix"

# Calculate correlations between key variables
correlation_data <- final_dataset |>
  filter(age_band == "All") |>
  group_by(year, labour_status) |>
  summarise(
    fertility_rate = first(fertility_rate),
    total_count     = sum(count, na.rm = TRUE),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from  = labour_status,
    values_from = total_count
  ) |>
  mutate(
    labour_participation_rate = labour_force / (labour_force + outside_labour_force),
    total_female_population   = labour_force + outside_labour_force
  )

# Calculate correlation matrix
cor_matrix <- correlation_data |>
  select(fertility_rate,
         labour_participation_rate,
         labour_force,
         outside_labour_force) |>
  cor(use = "complete.obs") |>
  round(3)

# Turn it into a tibble for gt
cor_tbl <- as.data.frame(cor_matrix) |>
  rownames_to_column(var = "Variable") |>
  as_tibble()

# Render with gt
cor_tbl |>
  gt(rowname_col = "Variable") |>
  tab_header(
    title = md("**Correlation Matrix: Key Variables**")
  ) |>
  fmt_number(
    columns = everything(),
    decimals = 3
  )

# Key correlation insights
cat("• Fertility Rate vs Labour Participation Rate:",
    cor_matrix["fertility_rate", "labour_participation_rate"], "\n")
cat("• Fertility Rate vs Labour Force:",
    cor_matrix["fertility_rate", "labour_force"], "\n")
cat("• Fertility Rate vs Outside Labour Force:",
    cor_matrix["fertility_rate", "outside_labour_force"], "\n")

```
There is a strong negative correlation between fertility rate and female labour participation and overall female labour force size. However, there is only a moderate correlation between fertility rate and overall female population outside of labour force.

**Trend Analysis**

```{r trend-analysis, echo=TRUE}
# Calculate year-over-year changes
trend_analysis <- final_dataset |>
  filter(age_band == "All") |>
  group_by(year, labour_status) |>
  summarise(
    fertility_rate = first(fertility_rate),
    total_count = sum(count, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(year) |>
  mutate(
    fertility_change = fertility_rate - lag(fertility_rate),
    fertility_pct_change = (fertility_rate - lag(fertility_rate)) / lag(fertility_rate) * 100
  )

# Summary statistics
summary_stats <- trend_analysis |>
  filter(!is.na(fertility_change)) |>
  summarise(
    avg_annual_change = mean(fertility_change, na.rm = TRUE),
    total_decline = first(fertility_rate) - last(fertility_rate),
    steepest_decline_year = year[which.min(fertility_change)],
    steepest_decline_value = min(fertility_change, na.rm = TRUE)
  )

cat("• Average annual fertility decline:", round(summary_stats$avg_annual_change, 4), "per year\n")
cat("• Total fertility decline (1990-2020):", round(summary_stats$total_decline, 2), "\n")
cat("• Steepest decline occurred in:", summary_stats$steepest_decline_year, "\n")
cat("• Steepest decline value:", round(summary_stats$steepest_decline_value, 3), "\n")
```

---

# Enhanced Data Visualisation

## Static Visualisation

```{r static-viz, echo=TRUE}
viz_data <- final_dataset |>
  group_by(year, marital_status, labour_status) |>
  summarise(count = sum(count, na.rm = TRUE), .groups = "drop") |>
  mutate(
    status = fct_inorder(paste(marital_status, labour_status, sep = " / "))
  )

fertility_line_data <- final_dataset |>
  filter(age_band == "All") |>
  distinct(year, fertility_rate) |>
  mutate(
    fertility_shift = fertility_rate - 1
  )

max_count    <- max(viz_data$count, na.rm = TRUE)
scale_factor <- max_count  

ggplot() +
  geom_col(
    data = viz_data,
    aes(x = year, y = count, fill = status),
    position = position_dodge(width = 0.8),
    colour = "white", size = 0.2
  ) +
  # Fertility line + points, using shifted & scaled fertility
  geom_line(
    data = fertility_line_data,
    aes(x = year, y = fertility_shift * scale_factor),
    colour = "gray69", size = 1
  ) +
  geom_point(
    data = fertility_line_data,
    aes(x = year, y = fertility_shift * scale_factor),
    colour = "gray45", size = 1
  ) +
  # Primary + secondary axes
  scale_y_continuous(
    name   = "Female Population (thousands)",
    labels = comma,
    limits = c(0, max_count),
    expand = expansion(c(0, 0)),
    sec.axis = sec_axis(
      # inverse of y = (fertility - 1) * scale_factor
      transform = ~ . / scale_factor + 1,
      name      = "Total Fertility Rate (per female)",
      breaks    = seq(1, 2, by = 0.25),
      labels    = label_number(accuracy = 0.1)
    )
  ) +
  # Manual fill colours
  scale_fill_manual(
    name   = "Marital Status / Labour Status",
    values = c(
      "married / labour_force"                  = "green3",
      "married / outside_labour_force"          = "darkgreen",
      "single / labour_force"                   = "red2",
      "single / outside_labour_force"           = "darkred",
      "widowed_divorced / labour_force"         = "blue1",
      "widowed_divorced / outside_labour_force" = "blue4"
    ),
    labels = c(
      "Married – In Labour Force",
      "Married – Outside Labour Force",
      "Single – In Labour Force",
      "Single – Outside Labour Force",
      "Divorced/Widowed – In Labour Force",
      "Divorced/Widowed – Outside Labour Force"
    )
  ) +
  labs(
    title   = "Singapore's Fertility Crisis: Labour Force vs TFR (1991–2020)",
    x       = "Year",
    caption = "Data: SingStat & data.gov.sg"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title      = element_text(face = "bold", size = 16),
    axis.title      = element_text(face = "bold"),
    legend.position = "bottom",
    legend.title    = element_text(face = "bold")
  )
```

## Interactive Dashboard
this code allows for clicking of the legend trace and labels to filter the data. but it has the ("label",1) naming issue

```{r interactive-agebanded-dashboard, echo=TRUE}
# 1. Aggregate labour counts across ALL age bands for each marital_status × labour_status
agg_counts <- final_dataset |>
  group_by(year, marital_status, labour_status) |>
  summarise(count = sum(count, na.rm = TRUE), .groups = "drop") |>
  mutate(
    status = fct_inorder(paste(marital_status, labour_status, sep = " / "))
  )

# 2. Crosstalk SharedData & filter
shared_counts <- SharedData$new(agg_counts, group = "labour_status_ab")
filter_ab <- filter_select(
  id         = "labour_ab_filter",
  label      = "Select Labour Status:",
  sharedData = shared_counts,
  group      = ~labour_status
)

# 3. Fertility lines by age_band (excluding the “All” total)
fertility_ab <- final_dataset |>
  filter(age_band != "All") |>
  distinct(year, age_band, fertility_rate)

# 4. Compute scale_factor so that max(fertility_rate) → max(count)
max_count     <- max(agg_counts$count,             na.rm = TRUE)
max_fertility <- max(fertility_ab$fertility_rate, na.rm = TRUE)
scale_factor  <- max_count / max_fertility

# 5. Build the ggplot
p_ab <- ggplot() +
  geom_col(
    data = shared_counts,
    aes(
      x    = year,
      y    = count,
      fill = status,
      group = status,
      text = paste0(
        "Year: ", year,
        "<br>Status: ", tools::toTitleCase(gsub("_"," ", status)),
        "<br>Count: ", comma(count)
      )
    ),
    position = position_dodge(width = 0.8),
    colour   = "white",
    size     = 0.2,
    alpha    = 0.8
  ) +
  geom_line(
    data = fertility_ab,
    aes(
      x      = year,
      y      = fertility_rate * scale_factor,
      colour = age_band,
      group  = age_band,
      text   = paste0(
        "Year: ", year,
        "<br>Age band: ", age_band,
        "<br>Fertility: ", round(fertility_rate,2)
      )
    ),
    size  = 0.8,
    alpha = 0.8
  ) +
  geom_point(
    data = fertility_ab,
    aes(
      x      = year,
      y      = fertility_rate * scale_factor,
      colour = age_band,
      group  = age_band,
      text   = paste0(
        "Year: ", year,
        "<br>Age band: ", age_band,
        "<br>Fertility: ", round(fertility_rate,2)
      )
    ),
    size = 1,
    show.legend = FALSE  # Hide points in legend
  ) +
  scale_y_continuous(
    name   = "Female Population (thousands)",
    labels = comma,
    sec.axis = sec_axis(
      transform = ~ . / scale_factor,
      name      = "Fertility Rate (per thousand females)",
      labels    = label_number(accuracy = 0.1)
    )
  ) +
  scale_fill_manual(
    name   = "Marital Status / Labour Status",
    values = c(
      "married / labour_force"                  = "green3",
      "married / outside_labour_force"          = "darkgreen",
      "single / labour_force"                   = "red2",
      "single / outside_labour_force"           = "darkred",
      "widowed_divorced / labour_force"         = "blue1",
      "widowed_divorced / outside_labour_force" = "blue4"
    )
  ) +
  scale_colour_brewer(
    palette = "Set2",
    name    = "Age Band"
  ) +
  labs(
    title    = "Age‐Banded Fertility Rates vs Female Labour Counts",
    subtitle = "Bars by Marital & Labour Status; Lines by Age Band",
    x        = "Year",
    caption  = "Data: SingStat & data.gov.sg"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title       = element_text(face = "bold", size = 12),
    plot.subtitle    = element_text(size = 12, color = "gray60"),
    axis.title       = element_text(face = "bold", size = 6),
    legend.position  = "bottom",
    panel.grid.minor = element_blank()
  )

# 6. Convert to Plotly with split = ~status so bars become 6 interactive traces
interactive_ab <- ggplotly(
  p_ab,
  tooltip = "text",
  split   = ~status
) %>%
  layout(
    legend = list(
      orientation = "h",
      x           = 0.5,
      xanchor     = "center",
      y           = -0.25,
      font        = list(size = 8),
      title       = list(
        text = "Marital Status / Labour Status",
        font = list(size = 10)
      ),
      itemwidth   = 70
    ),
    margin = list(
      l = 80, r = 80, b = 140, t = 80
    )
  )

# 7. Clean up legend names using direct trace modification
status_map <- c(
  "married / labour_force" = "Married – In Labour Force",
  "married / outside_labour_force" = "Married – Outside Labour Force",
  "single / labour_force" = "Single – In Labour Force",
  "single / outside_labour_force" = "Single – Outside Labour Force",
  "widowed_divorced / labour_force" = "Divorced/Widowed – In Labour Force",
  "widowed_divorced / outside_labour_force" = "Divorced/Widowed – Outside Labour Force"
)

# Get unique age bands from fertility data
age_bands <- unique(fertility_ab$age_band)

# Clean all trace names
for(i in seq_along(interactive_ab$x$data)) {
  trace <- interactive_ab$x$data[[i]]
  if(!is.null(trace$name)) {
    # Extract base name without Plotly's numbering
    base_name <- sub("(.*),\\d+$", "\\1", trace$name)
    
    # Clean bar traces (marital/labour status)
    if(base_name %in% names(status_map)) {
      interactive_ab$x$data[[i]]$name <- status_map[base_name]
      interactive_ab$x$data[[i]]$legendgroup <- status_map[base_name]
    } 
    # Clean line/point traces (age bands)
    else if(base_name %in% age_bands) {
      interactive_ab$x$data[[i]]$name <- base_name
      interactive_ab$x$data[[i]]$legendgroup <- base_name
    }
    # Fallback for other traces
    else {
      interactive_ab$x$data[[i]]$name <- base_name
      interactive_ab$x$data[[i]]$legendgroup <- base_name
    }
  }
}

# 8. Render
tagList(
  div(style = "margin-bottom:20px;",
      h3("Interactive Age‐Banded Fertility Dashboard"),
      p("Use the dropdown to filter bars by labour status.")
  ),
  filter_ab,
  interactive_ab
)
```

## Interactive Dashboard but with custom legend label
this one you cannot click on the legend traces and label but at least it looks nice. need to implement interactivity through the dropdown
```{r}

# 1. Aggregate labour counts across ALL age bands for each marital_status × labour_status
agg_counts <- final_dataset |>
  group_by(year, marital_status, labour_status) |>
  summarise(count = sum(count, na.rm = TRUE), .groups = "drop") |>
  mutate(
    status = fct_inorder(paste(marital_status, labour_status, sep = " / "))
  )

# 2. Crosstalk SharedData & filter
shared_counts <- SharedData$new(agg_counts, group = "labour_status_ab")
filter_ab <- filter_select(
  id         = "labour_ab_filter",
  label      = "Select Labour Status:",
  sharedData = shared_counts,
  group      = ~labour_status
)

# 3. Fertility lines by age_band (excluding the “All” total)
fertility_ab <- final_dataset |>
  filter(age_band != "All") |>
  distinct(year, age_band, fertility_rate)

# 4. Compute scale_factor so that max(fertility_rate) → max(count)
max_count     <- max(agg_counts$count,             na.rm = TRUE)
max_fertility <- max(fertility_ab$fertility_rate, na.rm = TRUE)
scale_factor  <- max_count / max_fertility

# 5. Build the ggplot
p_ab <- ggplot() +
  geom_col(
    data = shared_counts,
    aes(
      x           = year,
      y           = count,
      fill        = status,
      group       = status,
      legendgroup = status,
      text        = paste0(
        "Year: ", year,
        "<br>Status: ", tools::toTitleCase(gsub("_"," ", status)),
        "<br>Count: ", comma(count)
      )
    ),
    position = position_dodge(width = 0.8),
    colour   = "white",
    size     = 0.2,
    alpha    = 0.8
  ) +
  geom_line(
    data = fertility_ab,
    aes(
      x           = year,
      y           = fertility_rate * scale_factor,
      colour      = age_band,
      group       = age_band,
      legendgroup = age_band,
      text        = paste0(
        "Year: ", year,
        "<br>Age band: ", age_band,
        "<br>Fertility: ", round(fertility_rate,2)
      )
    ),
    size = 0.8,
    alpha = 0.8
  ) +
  geom_point(
    data = fertility_ab,
    aes(
      x      = year,
      y      = fertility_rate * scale_factor,
      colour = age_band,
      group  = age_band,
      legendgroup = age_band,
      text   = paste0(
        "Year: ", year,
        "<br>Age band: ", age_band,
        "<br>Fertility: ", round(fertility_rate,2)
      )
    ),
    size = 1
  ) +
  scale_y_continuous(
    name   = "Female Population (thousands)",
    labels = comma,
    sec.axis = sec_axis(
      transform = ~ . / scale_factor,
      name      = "Fertility Rate (per thousand females)",
      labels    = label_number(accuracy = 0.1)
    )
  ) +
  scale_fill_manual(
    name   = "Marital Status / Labour Status",
    values = c(
      "married / labour_force"                  = "green3",
      "married / outside_labour_force"          = "darkgreen",
      "single / labour_force"                   = "red2",
      "single / outside_labour_force"           = "darkred",
      "widowed_divorced / labour_force"         = "blue1",
      "widowed_divorced / outside_labour_force" = "blue4"
    )
  ) +
  scale_colour_brewer(
    palette = "Set2",
    name    = "Age Band"
  ) +
  labs(
    title    = "Age‐Banded Fertility Rates vs Female Labour Counts",
    subtitle = "Bars by Marital & Labour Status; Lines by Age Band",
    x        = "Year",
    caption  = "Data: SingStat & data.gov.sg"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title       = element_text(face = "bold", size = 12),
    plot.subtitle    = element_text(size = 12, color = "gray60"),
    axis.title       = element_text(face = "bold", size = 6),
    legend.position  = "bottom",
    panel.grid.minor = element_blank()
  )

# 6. Convert to Plotly
interactive_ab <- ggplotly(p_ab, tooltip = "text") %>%
  layout(
    legend = list(
      orientation = "h",
      x           = 0.5,
      xanchor     = "center",
      y           = -0.25,
      font        = list(size =  8 ),           # items
      title       = list(                           # title styling
        text = "Marital Status / Labour Status",
        font = list(size = 10 )
      ),
      itemwidth   = 70                              # force wrapping
    ),
    margin = list(
      l = 80,    # left
      r = 80,    # right
      b = 140,   # bottom (more for 2‐line legend)
      t = 80
    )
  )

# 7. Turn off the built‑in legend entries
for(i in seq_along(interactive_ab$x$data)) {
  interactive_ab$x$data[[i]]$showlegend <- FALSE
}

# 8. Create custom legend traces

# Status legend entries (squares)
status_labels <- c(
  "Married – In Labour Force",
  "Married – Outside Labour Force",
  "Single – In Labour Force",
  "Single – Outside Labour Force",
  "Divorced/Widowed – In Labour Force",
  "Divorced/Widowed – Outside Labour Force"
)
status_colors <- c("green3", "darkgreen", "red2", "darkred", "blue1", "blue4")

status_traces <- lapply(seq_along(status_labels), function(i) {
  list(
    name       = status_labels[i],
    legendgroup= status_labels[i],
    x          = NA,  y = NA,
    showlegend = TRUE,
    type       = "scatter",
    mode       = "markers",
    marker     = list(
      color  = status_colors[i],
      symbol = "square",
      size   = 6
    )
  )
})

# Age‐band legend entries (line swatches)
age_bands  <- c("15-19","20-24","25-29","30-34","35-39","40-44","45-49")
age_colors <- RColorBrewer::brewer.pal(length(age_bands), "Set2")

age_traces <- lapply(seq_along(age_bands), function(i) {
  list(
    name       = age_bands[i],
    legendgroup= age_bands[i],
    x          = NA,  y = NA,
    showlegend = TRUE,
    type       = "scatter",
    mode       = "lines",
    line       = list(
      color = age_colors[i],
      width = 2
    )
  )
})

# 9. Append custom legend traces
interactive_ab$x$data <- c(
  interactive_ab$x$data,
  status_traces,
  age_traces
)

# 10. Render
tagList(
  div(style = "margin-bottom:20px;",
      h3("Interactive Age‐Banded Fertility Dashboard"),
      p("Use the dropdown to filter bars by labour status.")
  ),
  filter_ab,
  interactive_ab
)
```

---

# Key Findings & Insights

## Summary Statistics


## Statistical Significance Testing


---

# Team Contributions


```
